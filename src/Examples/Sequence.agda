{-# OPTIONS --prop --rewriting #-}

module Examples.Sequence where

open import Calf
open import Calf.Types.Unit
open import Calf.Types.Product
open import Calf.Types.Sum
open import Calf.Types.Bool
open import Calf.Types.Maybe
open import Calf.Types.Nat
open import Calf.Types.List

open import Level using (0â„“)
open import Relation.Binary
open import Data.Nat as Nat using (_<_)
import Data.Nat.Properties as Nat
open import Data.String using (String)
open import Relation.Binary.PropositionalEquality as Eq using (_â‰¡_)

open import Function using (case_of_)


open import Examples.Sequence.MSequence
open import Examples.Sequence.ListMSequence
open import Examples.Sequence.RedBlackMSequence


module Ex/FromList where
  open MSequence RedBlackMSequence

  fromList : cmp (Î  (list nat) Î» _ â†’ F (seq nat))
  fromList [] = empty
  fromList (x âˆ· l) =
    bind (F (seq nat)) empty Î» sâ‚ â†’
    bind (F (seq nat)) (fromList l) Î» sâ‚‚ â†’
    join sâ‚ x sâ‚‚

  example : cmp (F (seq nat))
  example = fromList (1 âˆ· 2 âˆ· 3 âˆ· 4 âˆ· 5 âˆ· [])


module BinarySearchTree
  (MSeq : MSequence)
  (Key : StrictTotalOrder 0â„“ 0â„“ 0â„“)
  where

  open StrictTotalOrder Key

  ğ•‚ : tp pos
  ğ•‚ = U (meta (StrictTotalOrder.Carrier Key))

  open MSequence MSeq public

  singleton : cmp (Î  ğ•‚ Î» _ â†’ F (seq ğ•‚))
  singleton a =
    bind (F (seq ğ•‚)) empty Î» t â†’
    join t a t

  Split : tp neg
  Split = F (prodâº (seq ğ•‚) (prodâº (maybe ğ•‚) (seq ğ•‚)))

  split : cmp (Î  (seq ğ•‚) Î» _ â†’ Î  ğ•‚ Î» _ â†’ Split)
  split t a =
    rec
      {X = F (prodâº (seq ğ•‚) (prodâº (maybe ğ•‚) (seq ğ•‚)))}
      (bind Split empty Î» t â†’
        ret (t , nothing , t))
      (Î» tâ‚ ihâ‚ a' tâ‚‚ ihâ‚‚ â†’
        case compare a a' of Î»
          { (tri< a<a' Â¬aâ‰¡a' Â¬a>a') â†’
              bind Split ihâ‚ Î» ( tâ‚â‚ , a? , tâ‚â‚‚ ) â†’
              bind Split (join tâ‚â‚‚ a' tâ‚‚) Î» t â†’
              ret (tâ‚â‚ , a? , t)
          ; (triâ‰ˆ Â¬a<a' aâ‰¡a' Â¬a>a') â†’ ret (tâ‚ , just a' , tâ‚‚)
          ; (tri> Â¬a<a' Â¬aâ‰¡a' a>a') â†’
              bind Split ihâ‚‚ Î» ( tâ‚‚â‚ , a? , tâ‚‚â‚‚ ) â†’
              bind Split (join tâ‚ a' tâ‚‚â‚) Î» t â†’
              ret (t , a? , tâ‚‚â‚‚)
          })
      t

  find : cmp (Î  (seq ğ•‚) Î» _ â†’ Î  ğ•‚ Î» _ â†’ F (maybe ğ•‚))
  find t a = bind (F (maybe ğ•‚)) (split t a) Î» { (_ , a? , _) â†’ ret a? }

  insert : cmp (Î  (seq ğ•‚) Î» _ â†’ Î  ğ•‚ Î» _ â†’ F (seq ğ•‚))
  insert t a = bind (F (seq ğ•‚)) (split t a) Î» { (tâ‚ , _ , tâ‚‚) â†’ join tâ‚ a tâ‚‚ }


module Ex/NatSet where
  open BinarySearchTree RedBlackMSequence Nat.<-strictTotalOrder

  example : cmp Split
  example =
    bind Split (singleton 1) Î» tâ‚ â†’
    bind Split (insert tâ‚ 2) Î» tâ‚ â†’
    bind Split (singleton 4) Î» tâ‚‚ â†’
    bind Split (join tâ‚ 3 tâ‚‚) Î» t â†’
    split t 2


module Ex/NatStringDict where
  strictTotalOrder : StrictTotalOrder 0â„“ 0â„“ 0â„“
  strictTotalOrder =
    record
      { Carrier = â„• Ã— String
      ; _â‰ˆ_ = Î» (nâ‚ , _) (nâ‚‚ , _) â†’ nâ‚ â‰¡ nâ‚‚
      ; _<_ = Î» (nâ‚ , _) (nâ‚‚ , _) â†’ nâ‚ < nâ‚‚
      ; isStrictTotalOrder =
          record
            { isEquivalence =
                record
                  { refl = Eq.refl
                  ; sym = Eq.sym
                  ; trans = Eq.trans
                  }
            ; trans = Nat.<-trans
            ; compare = Î» (nâ‚ , _) (nâ‚‚ , _) â†’ Nat.<-cmp nâ‚ nâ‚‚
            }
      }

  open BinarySearchTree RedBlackMSequence strictTotalOrder

  example : cmp Split
  example =
    bind Split (singleton (1 , "red")) Î» tâ‚ â†’
    bind Split (insert tâ‚ (2 , "orange")) Î» tâ‚ â†’
    bind Split (singleton (4 , "green")) Î» tâ‚‚ â†’
    bind Split (join tâ‚ (3 , "yellow") tâ‚‚) Î» t â†’
    split t (2 , "")
