# **calf**: A Cost-Aware Logical Framework

The **calf** language is a **c**ost-**a**ware **l**ogical **f**ramework for studying quantitative aspects of functional programs.

This repository contains the Agda implementation of **calf**, as well as some case studies of varying complexity.

## HTML Browsing

The source code may be viewed interactively with (semantic) syntax highlighting in the browser using the HTML files in the [`./html`](./html) directory.
These files were generated by running:
```sh
agda --html --html-dir=html src/index.agda
```

You may want to start by opening [`html/index.html`](./html/index.html).

To view a specific module `M`, open `html/M.html` in a web browser.
For example, open [`html/Examples.Sorting.Parallel.html`](./html/Examples.Sorting.Parallel.html) to view the module `Examples.Sorting.Parallel`.

## Installation

This implementation of **calf** has been tested using:
- Agda v2.6.3, with `agda-stdlib` v2.0 experimental

Installation instructions may be found in [`INSTALL.md`](./INSTALL.md).

## Language Implementation

### Cost Monoid Parameterization

**calf** is parameterized by a *cost monoid* `(‚ÑÇ, +, zero, ‚â§)`.
The formal definition, `CostMonoid`, is given in [`Algebra.Cost`](./src/Algebra/Cost.agda).
The definition of a *parallel cost monoid* `(‚ÑÇ, ‚äï, ùüò, ‚äó, ùüô, ‚â§)` is given, as well, as `ParCostMonoid`.

Some common cost monoids and parallel cost monoids are given in [`Algebra.Cost.Instances`](./src/Algebra/Cost/Instances.agda); for example, `‚Ñï-CostMonoid` simply tracks sequential cost.
Note that every `ParCostMonoid` induces a `CostMonoid` via the additive substructure `(‚ÑÇ, ‚äï, ùüò, ‚â§)`.

### Core Language

The language itself is implemented via the following files, which are given in a dependency-respecting order.

The following modules are not parameterized:
- [`Calf.Prelude`](./src/Calf/Prelude.agda) contains commonly-used definitions.
- [`Calf.CBPV`](./src/Calf/CBPV.agda) defines the basic dependent Call-By-Push-Value (CBPV) language, using Agda `postulate`s and rewrite rules.
- [`Calf.Directed`](./src/Calf/Directed.agda) defines a preorder on each type, per the developments in [**decalf**](https://arxiv.org/abs/2307.05938).
- [`Calf.Phase`](./src/Calf/Phase.agda) defines the phase distinction of extension and intension:
  - [`Calf.Phase.Core`](./src/Calf/Phase/Core.agda) postulates a proposition, `ext`, for the extensional phase.
  - [`Calf.Phase.Open`](./src/Calf/Phase/Open.agda) defines the open/extensional modality `‚óØ` for `ext`.
  - [`Calf.Phase.Closed`](./src/Calf/Phase/Closed.agda) defines the closed/intensional modality `‚óè` for `ext`.
  - [`Calf.Phase.Directed`](./src/Calf/Phase/Directed.agda) postulates the **decalf** law that under `ext`, inequality coincides with equality.
  - [`Calf.Phase.Noninterference`](./src/Calf/Phase/Noninterference.agda) contains theorems related to the phase distinction/noninterference.

The following modules are parameterized by a `CostMonoid`:
- [`Calf.Step`](./src/Calf/Step.agda) defines the computational effect `step` and the associated coherence laws via rewrite rules.

The following modules are parameterized by a `ParCostMonoid`:
- [`Calf.Parallel`](./src/Calf/Parallel.agda) defines the parallel execution operation `_‚à•_` whose cost structure is given by the product operation of a `ParCostMonoid` (i.e., `_‚äó_`).

### Types

In [`src/Calf/Data`](./src/Calf/Data), we provide commonly-used data types.

The following modules are not parameterized and simply internalize the associated Agda types via the `meta‚Å∫` primitive:
- [`Calf.Data.Bool`](./src/Calf/Data/Bool.agda)
- [`Calf.Data.Equality`](./src/Calf/Data/Equality.agda)
- [`Calf.Data.List`](./src/Calf/Data/List.agda)
- [`Calf.Data.Maybe`](./src/Calf/Data/Maybe.agda)
- [`Calf.Data.Nat`](./src/Calf/Data/Nat.agda)
- [`Calf.Data.Product`](./src/Calf/Data/Product.agda)
- [`Calf.Data.Sum`](./src/Calf/Data/Sum.agda)

The following modules define custom, **calf**-specific data types for cost analysis and are parameterized by a `CostMonoid`:
- [`Calf.Data.IsBoundedG`](./src/Calf/Data/IsBoundedG.agda) defines a generalized notion of cost bound, `IsBoundedG`, where a bound is a program of type `F unit`.
  Additionally, it provides lemmas for proving the boundedness of common forms of computations.
- [`Calf.Data.IsBounded`](./src/Calf/Data/IsBounded.agda) instantiates `IsBoundedG` for cost bounds of the form `step (F unit) c (ret triv)`.
- [`Calf.Data.BoundedFunction`](./src/Calf/Data/BoundedFunction.agda) defines cost-bounded functions using `IsBounded`.
- [`Calf.Data.BigO`](./src/Calf/Types/BigO.agda) gives a definition of "big-O" asymptotic bounds via `IsBounded`.
  In particular, an element of the type `given A measured-via size , f ‚ààùìû(g)` (i.e., "given an input of type `A` and a size measure `size` on `A`, `f` is in `ùìû(g)`) is a lower bound on input sizes `n'` and a constant multiplier `k` along with a proof `h` that for all inputs `x` with `n' ‚â§ size x`, `f x` is bounded by `k` multiples of `g (size x)`, denoted `n' ‚â§n‚áíf[n]‚â§ k g[n]via h`.

## Examples

We provide a variety of case studies in [`src/Examples`](./src/Examples).

### Sequential Algorithms

#### [`Examples.Id`](./src/Examples/Id.agda)
- `module Easy`
  - Definition of the program `id` that trivially returns its input.
  - Definition of the cost bound program `id/bound`, which here is the same as `id`.
  - Theorem `id/is-bounded` showing that `id` is bounded by `id/bound`.
  - Theorem `id/correct` stating the extensional correctness of `id` as a corollary of `id/is-bounded`.
  - Theorem `id/asymptotic : given nat measured-via (Œª n ‚Üí n) , id ‚ààùìû(Œª n ‚Üí 0)` stating that `id` is in `ùìû(0)`.
- `module Hard`
  - Definition of the program `id` that reconstructs its input via induction.
  - Definition of the cost bound program `id/bound`, which incurs `n` cost before returning `n`.
  - Theorem `id/is-bounded` showing that `id` is bounded by `id/bound`.
  - Theorem `id/correct` stating the extensional correctness of `id` as a corollary of `id/is-bounded`.
  - Theorem `id/asymptotic : given nat measured-via (Œª n ‚Üí n) , id ‚ààùìû(Œª n ‚Üí n)` stating that `id` is in `ùìû(n)`, where `n` is the input number.
- A proof that `Easy.id` and `Hard.id` are extensionally equivalent, `easy‚â°hard : ‚óØ (Easy.id ‚â° Hard.id)`, as a corollary of the `id/correct` proofs.

<!--
#### [`Examples.Gcd`](./src/Examples/Gcd.agda)
- A **calf** implementation of Euclid's algorithm for gcd.
- [`Examples.Gcd.Euclid`](./src/Examples/Gcd/Euclid.agda)
  - Specification of the cost model via the instrumented operation `mod`.
  - Definition of the type `gcd/i`, which specifies that inputs to Euclid's algorithm should be ordered (first is greater than second).
  - Definition of the program `gcd/depth` that computes the recursion depth of Euclid's algorithm.
- [`Examples.Gcd.Clocked`](./src/Examples/Gcd/Clocked.agda)
  - The clocked version of Euclid's algorithm `gcd/clocked` in which the first parameter is used to justify recursive calls.
  - The actual algorithm `gcd`, obtained by instantiating the clock parameter by `gcd/depth`.
  - The theorem `gcd‚â§gcd/depth` stating that the cost of Euclid's algorithm is bounded by the recursion depth `gcd/depth`.
- [`Examples.Gcd.Spec`](./src/Examples/Gcd/Spec.agda)
  - Theorems `gcd‚â°spec/zero` and `gcd‚â°spec/suc` stating the behavioral correctness of `gcd` in terms of the defining equations of Euclid's algorithm.
- [`Examples.Gcd.Refine`](./src/Examples/Gcd/Refine.agda)
  - Refinement of the bound `gcd/depth` -- the theorem `gcd/depth‚â§gcd/depth/closed` states that the cost of `gcd` is bounded by `suc ‚àò fib‚Åª¬π`.
-->

### Parallel Algorithms

#### [`Examples.TreeSum`](./src/Examples/TreeSum.agda)
- Definition of the program `sum` that sums the elements of a tree, incurring unit cost when performing each addition operation.
  At each node, the recursive calls are computed in parallel.
- Definition of the cost bound program `sum/bound`, which incurs `size t , depth t` cost before returning the sum of the tree via a value-level function.
- Theorem `sum/has-cost` stating that `sum` and `sum/bound` are equivalent.
- Theorem `sum/is-bounded` stating that the cost of `sum t` is bounded by `sum/bound`, as a corollary of `sum/has-cost`.

#### [`Examples.Exp2`](./src/Examples/Exp2.agda)
- `module Slow`
  - Definition of the program `exp‚ÇÇ` that computes the exponentation of two by its input by performing two identical recursive calls.
    Since two identical recursive calls are made in parallel, the work is exponential, but the span is still linear.
  - Definition of the cost bound program `exp‚ÇÇ/bound`, incurring `2 ^ n - 1 , n` cost before returning result `2 ^ n`.
  - Theorem `exp‚ÇÇ/is-bounded` showing that `exp‚ÇÇ` is bounded by `exp‚ÇÇ/bound`.
  - Theorem `exp‚ÇÇ/correct` stating the extensional correctness of `exp‚ÇÇ` as a corollary of `exp‚ÇÇ/is-bounded`.
  - Theorem `exp‚ÇÇ/asymptotic : given nat measured-via (Œª n ‚Üí n) , exp‚ÇÇ ‚ààùìû(Œª n ‚Üí 2 ^ n , n)` stating that `exp‚ÇÇ` is in `ùìû(2 ^ n , n)`.
- `module Fast`
  - Definition of the program `exp‚ÇÇ` which computes the exponentation of two by its input via a standard recursive algorithm.
  - Definition of the cost bound program `exp‚ÇÇ/bound`, incurring `n , n` cost before returning result `2 ^ n`.
  - Theorem `exp‚ÇÇ/is-bounded` showing that `exp‚ÇÇ` is bounded by `exp‚ÇÇ/bound`.
  - Theorem `exp‚ÇÇ/correct` stating the extensional correctness of `exp‚ÇÇ` as a corollary of `exp‚ÇÇ/is-bounded`.
  - Theorem `exp‚ÇÇ/asymptotic : given nat measured-via (Œª n ‚Üí n) , exp‚ÇÇ ‚ààùìû(Œª n ‚Üí n , n)` stating that `exp‚ÇÇ` is in `ùìû(n , n)`.
- A proof that `Slow.exp‚ÇÇ` and `Fast.exp‚ÇÇ` are extensionally equivalent, `slow‚â°fast : ‚óØ (Slow.exp‚ÇÇ ‚â° Fast.exp‚ÇÇ)`.

### Hybrid Algorithms

#### [`Examples.Sorting`](./src/Examples/Sorting.agda)
First, we develop a common collection of definitions and theorems used in both sequential and parallel sorting.
- [`Examples.Sorting.Comparable`](./src/Examples/Sorting/Comparable.agda)
  - Record `Comparable` describing the requirements for a type to be comparable, including `h-cost`, a hypothesis that each comparison is bounded by unit cost.
    This serves as the cost model for sorting.
- [`Examples.Sorting.Core`](./src/Examples/Sorting/Core.agda)
  - Predicates for correctness of sorting, based on `Sorted` and the permutation relation `‚Ü≠` from `agda-stdlib`.
    The predicate `IsSort sort` states that `sort` is a correct sorting algorithm.
  - Theorem `IsSort‚áí‚â°`, which states that any two correct sorting algorithms are extensionally equivalent.

##### [`Examples.Sorting.Sequential`](./src/Examples/Sorting/Sequential.agda)
Here, we use cost monoid `‚Ñï-CostMonoid`, tracking the total number of sequential steps incurred.

- [`Examples.Sorting.Sequential.InsertionSort`](./src/Examples/Sorting/Sequential/InsertionSort.agda)
  - Definition of the program `sort` implementing insertion sort.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = length l ¬≤`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n ¬≤)` stating that `sort` is in `ùìû(n ¬≤)`, where `n` is the length of the input list.
- [`Examples.Sorting.Sequential.MergeSort`](./src/Examples/Sorting/Sequential/MergeSort.agda)
    - [`Examples.Sorting.Sequential.MergeSort.Split`](./src/Examples/Sorting/Sequential/MergeSort/Split.agda)
      - Definition of the program `split`, which splits a list in halves.
      - Theorem `split/correct` verifying correctness properties of `split`.
      - Theorem `split‚â§split/cost` stating that the cost of `split l` is bounded by `zero`, since splitting a list into halves requires no comparisons.
    - [`Examples.Sorting.Sequential.MergeSort.Merge`](./src/Examples/Sorting/Sequential/MergeSort/Merge.agda)
      - Definition of the program `merge`, which merges a pair of sorted lists.
      - Theorem `merge/correct` verifying correctness properties of `merge`.
      - Theorem `merge‚â§merge/cost/closed` stating that the cost of `merge (l‚ÇÅ , l‚ÇÇ)` is bounded by `length l‚ÇÅ + length l‚ÇÇ`.
  - Definition of the program `sort` implementing merge sort.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = ‚åàlog‚ÇÇ length l ‚åâ * length l`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n * ‚åàlog‚ÇÇ n ‚åâ)` stating that `sort` is in `ùìû(n * ‚åàlog‚ÇÇ n ‚åâ)`, where `n` is the length of the input list.

Theorem `isort‚â°msort : ‚óØ (ISort.sort ‚â° MSort.sort)` states that `InsertionSort.sort` and `MergeSort.sort` are extensionally equivalent.

<!--
##### [`Examples.Sorting.Parallel`](./src/Examples/Sorting/Parallel.agda)
Here, we use *parallel* cost monoid `‚Ñï¬≤-ParCostMonoid`, tracking a pair of natural numbers corresponding to the work (sequential cost) and span (idealized parallel cost), respectively.

- [`Examples.Sorting.Parallel.InsertionSort`](./src/Examples/Sorting/Parallel/InsertionSort.agda)
  - Definition of the program `sort` implementing insertion sort.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = (length l ¬≤ , length l ¬≤)`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n  ¬≤ , n  ¬≤)` stating that `sort` is in `ùìû(n  ¬≤)` work and `ùìû(n  ¬≤)` span, where `n` is the length of the input list.
- [`Examples.Sorting.Parallel.MergeSort`](./src/Examples/Sorting/Parallel/MergeSort.agda)
    - [`Examples.Sorting.Parallel.MergeSort.Split`](./src/Examples/Sorting/Parallel/MergeSort/Split.agda)
      - Definition of the program `split`, which splits a list in halves.
      - Theorem `split/correct` verifying correctness properties of `split`.
      - Theorem `split‚â§split/cost` stating that the cost of `split l` is bounded by `ùüò = (zero , zero)`, since splitting a list into halves requires no comparisons.
    - [`Examples.Sorting.Parallel.MergeSort.Merge`](./src/Examples/Sorting/Parallel/MergeSort/Merge.agda)
      - Definition of the program `merge`, which *sequentially* merges a pair of sorted lists.
      - Theorem `merge/correct` verifying correctness properties of `merge`.
      - Theorem `merge‚â§merge/cost/closed` stating that the cost of `merge (l‚ÇÅ , l‚ÇÇ)` is bounded by `(length l‚ÇÅ + length l‚ÇÇ , length l‚ÇÅ + length l‚ÇÇ)`, since this implementation of `merge` is sequential.
  - Definition of the program `sort` implementing merge sort, where both recursive calls to `sort` are performed in parallel (via the parallel pairing operation `_‚à•_`).
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = (‚åàlog‚ÇÇ length l ‚åâ * length l , 2 * length l + ‚åàlog‚ÇÇ length l ‚åâ)`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n * ‚åàlog‚ÇÇ n ‚åâ , n)` stating that `sort` is in `ùìû(n * ‚åàlog‚ÇÇ n ‚åâ)` work and `ùìû(n)` span, where `n` is the length of the input list.
- [`Examples.Sorting.Parallel.MergeSortPar`](./src/Examples/Sorting/Parallel/MergeSortPar.agda)
    - [`Examples.Sorting.Parallel.MergeSortPar.Merge`](./src/Examples/Sorting/Parallel/MergeSortPar/Merge.agda)
      - Definition of the program `merge`, which merges a pair of sorted lists *in parallel* using auxiliary functions `splitMid` and `splitBy`.
      - Theorem `merge/correct` verifying correctness properties of `merge`.
      - Theorem `merge‚â§merge/cost/closed` stating that the cost of `merge (l‚ÇÅ , l‚ÇÇ)` is bounded by `(pred[2^ ‚åàlog‚ÇÇ suc (length l‚ÇÅ) ‚åâ ] * ‚åàlog‚ÇÇ suc (length l‚ÇÇ) ‚åâ , ‚åàlog‚ÇÇ suc (length l‚ÇÅ) ‚åâ * ‚åàlog‚ÇÇ suc (length l‚ÇÇ) ‚åâ)`, where `pred[2^ n ] = (2 ^ n) - 1`.
  - Definition of the program `sort` implementing merge sort, where both recursive calls to `sort` are performed in parallel.
    This is identical to `MergeSort.sort`, but using the parallel merge operation `MergeSortPar.Merge.Merge`.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = (‚åàlog‚ÇÇ length l ‚åâ * length l * ‚åàlog‚ÇÇ suc ‚åà length l /2‚åâ ‚åâ , ‚åàlog‚ÇÇ length l ‚åâ * ‚åàlog‚ÇÇ suc ‚åà length l /2‚åâ ‚åâ ¬≤)`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n * ‚åàlog‚ÇÇ n ‚åâ ¬≤ , ‚åàlog‚ÇÇ n ‚åâ ^ 3)` stating that `sort` is in `ùìû(n * ‚åàlog‚ÇÇ n ‚åâ ¬≤)` work and `ùìû(‚åàlog‚ÇÇ n ‚åâ ^ 3)` span, where `n` is the length of the input list.

Theorem `isort‚â°msort : ‚óØ (ISort.sort ‚â° MSort.sort)` states that `InsertionSort.sort` and `MergeSort.sort` are extensionally equivalent.
Similarly, `msort‚â°psort : ‚óØ (MSort.sort ‚â° PSort.sort)` states that `MergeSort.sort` and `MergeSortPar.sort` are extensionally equivalent.
-->

### Data Structures

#### Amortized

<!--
##### [`Examples.Queue`](./src/Examples/Queue.agda)
- A **calf** implementation of [Batched queues](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)#Amortized_queue).
- Specification of the cost model as the number of list iterations via the axiom `list/ind/cons`.
- Upper bounds on the cost of individual enqueue and dequeue operations:
  - The theorem `enq‚â§enq/cost` stating that enqueue has zero cost.
  - The theorem `deq‚â§deq/cost` stating that dequeue has linear cost.
- Amortized analysis of sequences of enqueue and dequeue operations:
  - The theorem `acost‚â§2*|l|` stating that the amortized cost of a sequence of queue operations is at most twice the length of the sequence.
-->

##### [`Examples.Amortized`](./src/Examples/Amortized.agda)

Amortized data structures, [via coinduction](https://drops.dagstuhl.de/opus/volltexte/2023/18820).

- [`Examples.Amortized.Simple`](./src/Examples/Amortized/Simple.agda) provides an amortized implementation of a simple amortized stream abstract data type.
- [`Examples.Amortized.Queue`](./src/Examples/Amortized/Queue.agda) provides an implementation of [amortized queues](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)#Amortized_queue).
- [`Examples.Amortized.DynamicArray`](./src/Examples/Amortized/DynamicArray.agda) provides an implementation of dynamically-growing arrays.
